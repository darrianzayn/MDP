//+------------------------------------------------------------------+
//|                                    EA XAUUSD Smart v4.0         |
//|                          Upgraded with Strategic Improvements    |
//|                                        Copyright 2025, YourName |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025"
#property link      ""
#property version   "4.00"
#property strict

//--- üéØ PHASE 1 CRITICAL IMPROVEMENTS
//--- ATR-based SL/TP, Adaptive Cooldown, Smart Break-even, Dynamic Spread

//+------------------------------------------------------------------+
//| Input Parameters - Smart Configuration                           |
//+------------------------------------------------------------------+
input group "=== üöÄ CORE SETTINGS ==="
input double MaxRiskPerTrade = 1.5;        // Risk per trade (%)
input double BaseLotSize = 0.01;            // Base lot size
input bool   UseAggressiveMode = false;     // 2x Risk Mode
input int    MagicNumber = 12345;

input group "=== üõ°Ô∏è ANTI-REVENGE SYSTEM ==="
input int    MinCooldownMinutes = 15;       // Min cooldown after loss (minutes)
input int    MaxCooldownMinutes = 120;      // Max cooldown after loss (minutes)
input int    MaxConsecutiveLosses = 2;      // Max losses before lot reduction

input group "=== üéØ ATR-BASED RISK MANAGEMENT ==="
input int    ATR_Period = 14;               // ATR calculation period
input double ATR_SL_Multiplier = 2.0;       // SL = ATR √ó this multiplier
input double ATR_TP_Multiplier = 4.0;       // TP = ATR √ó this multiplier
input double ATR_Trail_Multiplier = 1.2;    // Trailing distance multiplier

input group "=== üìä MARKET CONDITIONS ==="
input double MaxSpreadATRMultiplier = 2.5;  // Max spread = ATR √ó this
input bool   UseSessionOptimization = true; // Optimize per trading session
input bool   AvoidHighVolatility = true;    // Skip when ATR > 150% average

input group "=== üéÆ SIGNAL SYSTEM ==="
input int    SignalMinStrength = 3;         // Min signal strength (1-5)
input bool   UseMultiTimeframe = true;      // M15 entry + H1 confirmation
input double ADX_TrendMinimum = 25.0;       // Min ADX for trend trading

input group "=== üí∞ POSITION SIZING ==="
input bool   UseEquityCurveMultiplier = true; // Adjust lot based on performance
input double PerformanceBonus = 0.25;       // Lot increase when winning (25%)
input double PerformancePenalty = 0.50;     // Lot decrease when losing (50%)

//+------------------------------------------------------------------+
//| Global Variables - Smart Memory                                  |
//+------------------------------------------------------------------+
datetime lastTradeTime = 0;
datetime cooldownEndTime = 0;
int consecutiveLosses = 0;
double lastEquity = 0;
double performanceMultiplier = 1.0;
double atrCurrent = 0;
double atrAverage = 0;
bool isInCooldown = false;
int totalTrades = 0;
int winningTrades = 0;

// Session tracking
bool isEUSession = false;
bool isUSSession = false;
bool isAsiaSession = false;
bool isPrimeTime = false;

// Smart break-even tracking
bool breakEvenMoved = false;
double breakEvenPrice = 0;

//+------------------------------------------------------------------+
//| Expert initialization - Smart Setup                              |
//+------------------------------------------------------------------+
int OnInit()
{
    Print("üöÄ EA XAUUSD Smart v4.0 - Tesla Autopilot Mode Activated!");
    
    // Initialize performance tracking
    lastEquity = AccountEquity();
    
    // Calculate initial ATR average (100 periods for stability)
    double atrSum = 0;
    for(int i = 1; i <= 100; i++)
    {
        atrSum += iATR(Symbol(), PERIOD_M15, ATR_Period, i);
    }
    atrAverage = atrSum / 100.0;
    
    Print("üìä ATR Average initialized: ", DoubleToStr(atrAverage, 5));
    Print("üí∞ Account Equity: $", DoubleToStr(AccountEquity(), 2));
    
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert tick function - Smart Brain                               |
//+------------------------------------------------------------------+
void OnTick()
{
    // Update real-time data
    UpdateMarketData();
    UpdateSessionData();
    UpdatePerformanceData();
    
    // Smart position management for existing trades
    ManageExistingPositions();
    
    // Check if we can trade (multiple intelligent filters)
    if(!CanTradeNow()) return;
    
    // Generate and evaluate signals
    int signalStrength = AnalyzeMarket();
    
    if(signalStrength >= SignalMinStrength)
    {
        // Execute smart trade with all improvements
        ExecuteSmartTrade(signalStrength);
    }
}

//+------------------------------------------------------------------+
//| Update Market Data - Market Intelligence                         |
//+------------------------------------------------------------------+
void UpdateMarketData()
{
    // Current ATR for dynamic adjustments
    atrCurrent = iATR(Symbol(), PERIOD_M15, ATR_Period, 1);
    
    // Update ATR average (simple moving average of last 50 values)
    static double atrBuffer[50];
    static int atrIndex = 0;
    
    atrBuffer[atrIndex] = atrCurrent;
    atrIndex = (atrIndex + 1) % 50;
    
    double atrSum = 0;
    for(int i = 0; i < 50; i++)
    {
        atrSum += atrBuffer[i];
    }
    atrAverage = atrSum / 50.0;
}

//+------------------------------------------------------------------+
//| Update Session Data - Timing Intelligence                        |
//+------------------------------------------------------------------+
void UpdateSessionData()
{
    int currentHour = Hour();
    
    // WIB timezone sessions
    isAsiaSession = (currentHour >= 9 && currentHour <= 11);   // Tokyo breakouts
    isEUSession = (currentHour >= 15 && currentHour <= 18);    // EU prime
    isUSSession = (currentHour >= 21 && currentHour <= 24);    // US momentum
    isPrimeTime = isEUSession || isUSSession;                  // Best volatility
}

//+------------------------------------------------------------------+
//| Update Performance Data - Performance Intelligence               |
//+------------------------------------------------------------------+
void UpdatePerformanceData()
{
    if(!UseEquityCurveMultiplier) return;
    
    double currentEquity = AccountEquity();
    double equityChange = currentEquity - lastEquity;
    
    // Update performance multiplier based on recent performance
    if(totalTrades >= 10) // Need minimum trades for statistical significance
    {
        double winRate = (double)winningTrades / totalTrades;
        
        if(winRate > 0.70) // Excellent performance
        {
            performanceMultiplier = 1.0 + PerformanceBonus;
        }
        else if(winRate < 0.40) // Poor performance
        {
            performanceMultiplier = 1.0 - PerformancePenalty;
        }
        else // Average performance
        {
            performanceMultiplier = 1.0;
        }
    }
    
    lastEquity = currentEquity;
}

//+------------------------------------------------------------------+
//| Check Trading Conditions - Multiple Smart Filters               |
//+------------------------------------------------------------------+
bool CanTradeNow()
{
    // 1. Check if in cooldown (adaptive system)
    if(TimeCurrent() < cooldownEndTime)
    {
        isInCooldown = true;
        return false;
    }
    isInCooldown = false;
    
    // 2. Dynamic spread filter (ATR-based)
    double maxAllowedSpread = atrCurrent * MaxSpreadATRMultiplier;
    if(MarketInfo(Symbol(), MODE_SPREAD) * Point > maxAllowedSpread)
    {
        return false;
    }
    
    // 3. High volatility filter (avoid chaos)
    if(AvoidHighVolatility && atrCurrent > atrAverage * 1.5)
    {
        return false;
    }
    
    // 4. Session optimization
    if(UseSessionOptimization && !isPrimeTime && !isAsiaSession)
    {
        return false; // Only trade during optimal sessions
    }
    
    // 5. Weekend protection
    if(DayOfWeek() == 5 && Hour() >= 21) // Friday 21:00 WIB
    {
        return false;
    }
    
    // 6. Check if already have open position
    if(CountOpenPositions() > 0)
    {
        // Allow second position only in aggressive mode with strong trend
        if(!UseAggressiveMode) return false;
        
        double adx = iADX(Symbol(), PERIOD_H1, 14, PRICE_CLOSE, MODE_MAIN, 1);
        if(adx < ADX_TrendMinimum * 1.5) return false; // Extra strong trend required
    }
    
    return true;
}

//+------------------------------------------------------------------+
//| Analyze Market - Signal Intelligence                             |
//+------------------------------------------------------------------+
int AnalyzeMarket()
{
    int signalStrength = 0;
    int direction = 0; // 1 = Buy, -1 = Sell
    
    // 1. Multi-timeframe analysis
    if(UseMultiTimeframe)
    {
        // M15 for entry signals
        double ma20_m15 = iMA(Symbol(), PERIOD_M15, 20, 0, MODE_SMA, PRICE_CLOSE, 1);
        double ma50_m15 = iMA(Symbol(), PERIOD_M15, 50, 0, MODE_SMA, PRICE_CLOSE, 1);
        
        // H1 for trend confirmation
        double ma20_h1 = iMA(Symbol(), PERIOD_H1, 20, 0, MODE_SMA, PRICE_CLOSE, 1);
        double ma50_h1 = iMA(Symbol(), PERIOD_H1, 50, 0, MODE_SMA, PRICE_CLOSE, 1);
        
        // Trend alignment check
        bool upTrendM15 = ma20_m15 > ma50_m15;
        bool upTrendH1 = ma20_h1 > ma50_h1;
        
        if(upTrendM15 && upTrendH1)
        {
            direction = 1;
            signalStrength += 2;
        }
        else if(!upTrendM15 && !upTrendH1)
        {
            direction = -1;
            signalStrength += 2;
        }
    }
    
    // 2. ADX trend strength
    double adx = iADX(Symbol(), PERIOD_M15, 14, PRICE_CLOSE, MODE_MAIN, 1);
    if(adx > ADX_TrendMinimum)
    {
        signalStrength += 1;
    }
    
    // 3. Price action patterns (simple)
    double open1 = iOpen(Symbol(), PERIOD_M15, 1);
    double close1 = iClose(Symbol(), PERIOD_M15, 1);
    double high1 = iHigh(Symbol(), PERIOD_M15, 1);
    double low1 = iLow(Symbol(), PERIOD_M15, 1);
    
    // Engulfing pattern detection
    double open2 = iOpen(Symbol(), PERIOD_M15, 2);
    double close2 = iClose(Symbol(), PERIOD_M15, 2);
    
    if(close1 > open1 && close2 < open2 && close1 > open2 && open1 < close2) // Bullish engulfing
    {
        if(direction == 1) signalStrength += 1;
    }
    else if(close1 < open1 && close2 > open2 && close1 < open2 && open1 > close2) // Bearish engulfing
    {
        if(direction == -1) signalStrength += 1;
    }
    
    // 4. Session-based signal adjustment
    if(isPrimeTime)
    {
        signalStrength += 1; // Higher confidence during prime hours
    }
    
    // Store direction for trade execution
    if(direction != 0)
    {
        GlobalVariableSet("SignalDirection", direction);
    }
    
    return signalStrength;
}

//+------------------------------------------------------------------+
//| Execute Smart Trade - Intelligent Execution                      |
//+------------------------------------------------------------------+
void ExecuteSmartTrade(int signalStrength)
{
    int direction = (int)GlobalVariableGet("SignalDirection");
    if(direction == 0) return;
    
    // Calculate smart position size
    double lotSize = CalculateSmartLotSize();
    
    // Calculate ATR-based SL and TP
    double slDistance = atrCurrent * ATR_SL_Multiplier;
    double tpDistance = atrCurrent * ATR_TP_Multiplier;
    
    double price = (direction == 1) ? Ask : Bid;
    double stopLoss = (direction == 1) ? price - slDistance : price + slDistance;
    double takeProfit = (direction == 1) ? price + tpDistance : price - tpDistance;
    
    // Execute the trade
    int ticket = OrderSend(
        Symbol(),
        (direction == 1) ? OP_BUY : OP_SELL,
        lotSize,
        price,
        3, // slippage
        stopLoss,
        takeProfit,
        "XAUUSD Smart v4.0 - S:" + IntegerToString(signalStrength),
        MagicNumber,
        0,
        (direction == 1) ? clrBlue : clrRed
    );
    
    if(ticket > 0)
    {
        Print("‚úÖ Smart Trade Executed - Ticket: ", ticket, 
              " | Direction: ", (direction == 1) ? "BUY" : "SELL",
              " | Lot: ", DoubleToStr(lotSize, 2),
              " | Signal Strength: ", signalStrength);
        
        lastTradeTime = TimeCurrent();
        breakEvenMoved = false; // Reset break-even flag
        totalTrades++;
    }
    else
    {
        Print("‚ùå Trade Failed - Error: ", GetLastError());
    }
}

//+------------------------------------------------------------------+
//| Calculate Smart Lot Size - Dynamic Position Sizing              |
//+------------------------------------------------------------------+
double CalculateSmartLotSize()
{
    double lotSize = BaseLotSize;
    
    // 1. Account scaling
    double equity = AccountEquity();
    if(equity >= 5000) lotSize = 0.05;
    else if(equity >= 1000) lotSize = 0.02;
    else lotSize = 0.01;
    
    // 2. Performance multiplier
    lotSize *= performanceMultiplier;
    
    // 3. Consecutive losses adjustment
    if(consecutiveLosses >= MaxConsecutiveLosses)
    {
        lotSize *= 0.5; // Reduce by 50%
    }
    
    // 4. Volatility adjustment
    double volAdjustment = atrAverage / atrCurrent;
    if(volAdjustment > 2.0) volAdjustment = 2.0; // Cap at 2x
    if(volAdjustment < 0.5) volAdjustment = 0.5; // Floor at 0.5x
    lotSize *= volAdjustment;
    
    // 5. Aggressive mode
    if(UseAggressiveMode)
    {
        lotSize *= 2.0;
    }
    
    // 6. Risk-based sizing
    double riskAmount = equity * (MaxRiskPerTrade / 100.0);
    double slDistance = atrCurrent * ATR_SL_Multiplier;
    double riskBasedLot = riskAmount / (slDistance / Point * MarketInfo(Symbol(), MODE_TICKVALUE));
    
    // Use the smaller of calculated lot or risk-based lot
    if(riskBasedLot < lotSize) lotSize = riskBasedLot;
    
    // Normalize lot size
    double minLot = MarketInfo(Symbol(), MODE_MINLOT);
    double maxLot = MarketInfo(Symbol(), MODE_MAXLOT);
    double lotStep = MarketInfo(Symbol(), MODE_LOTSTEP);
    
    lotSize = MathMax(minLot, MathMin(maxLot, MathRound(lotSize / lotStep) * lotStep));
    
    return lotSize;
}

//+------------------------------------------------------------------+
//| Manage Existing Positions - Profit Protection                    |
//+------------------------------------------------------------------+
void ManageExistingPositions()
{
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        if(!OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) continue;
        if(OrderSymbol() != Symbol() || OrderMagicNumber() != MagicNumber) continue;
        
        double currentPrice = (OrderType() == OP_BUY) ? Bid : Ask;
        double openPrice = OrderOpenPrice();
        double profit = (OrderType() == OP_BUY) ? (currentPrice - openPrice) : (openPrice - currentPrice);
        double profitPips = profit / Point;
        
        // Smart Break-Even
        if(!breakEvenMoved && profitPips >= 25)
        {
            double newSL = openPrice + ((OrderType() == OP_BUY) ? MarketInfo(Symbol(), MODE_SPREAD) * Point : -MarketInfo(Symbol(), MODE_SPREAD) * Point);
            
            if(OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0, clrYellow))
            {
                breakEvenMoved = true;
                Print("üõ°Ô∏è Break-Even activated for ticket: ", OrderTicket());
            }
        }
        
        // ATR-based Trailing Stop
        if(breakEvenMoved && profitPips >= 40)
        {
            double trailDistance = atrCurrent * ATR_Trail_Multiplier;
            double newSL = (OrderType() == OP_BUY) ? 
                          currentPrice - trailDistance : 
                          currentPrice + trailDistance;
            
            // Only move SL in favorable direction
            bool shouldUpdate = false;
            if(OrderType() == OP_BUY && newSL > OrderStopLoss())
                shouldUpdate = true;
            else if(OrderType() == OP_SELL && newSL < OrderStopLoss())
                shouldUpdate = true;
            
            if(shouldUpdate)
            {
                OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0, clrGreen);
            }
        }
        
        // Partial Exits
        if(profitPips >= 60 && OrderLots() > MarketInfo(Symbol(), MODE_MINLOT))
        {
            double closeLots = OrderLots() * 0.5; // Close 50%
            if(closeLots >= MarketInfo(Symbol(), MODE_MINLOT))
            {
                OrderClose(OrderTicket(), closeLots, currentPrice, 3, clrOrange);
                Print("üí∞ Partial exit: 50% closed at +", DoubleToStr(profitPips, 1), " pips");
            }
        }
        
        // Time-based exit (8 hours maximum)
        if(TimeCurrent() - OrderOpenTime() > 8 * 3600)
        {
            OrderClose(OrderTicket(), OrderLots(), currentPrice, 3, clrPurple);
            Print("‚è∞ Time-based exit: Trade closed after 8 hours");
        }
    }
}

//+------------------------------------------------------------------+
//| Count Open Positions                                             |
//+------------------------------------------------------------------+
int CountOpenPositions()
{
    int count = 0;
    for(int i = 0; i < OrdersTotal(); i++)
    {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
                count++;
        }
    }
    return count;
}

//+------------------------------------------------------------------+
//| Handle Trade Closure - Learning System                           |
//+------------------------------------------------------------------+
void OnTrade()
{
    // Check for recently closed trades
    int totalHistoryNow = OrdersHistoryTotal();
    static int lastHistoryTotal = 0;
    
    if(totalHistoryNow > lastHistoryTotal)
    {
        // New trade closed, analyze result
        if(OrderSelect(totalHistoryNow - 1, SELECT_BY_POS, MODE_HISTORY))
        {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
            {
                double profit = OrderProfit() + OrderSwap() + OrderCommission();
                
                if(profit > 0)
                {
                    // Winning trade
                    consecutiveLosses = 0;
                    winningTrades++;
                    Print("üéâ Win: +$", DoubleToStr(profit, 2));
                }
                else
                {
                    // Losing trade - activate adaptive cooldown
                    consecutiveLosses++;
                    
                    // Calculate adaptive cooldown based on volatility
                    int cooldownMinutes = MinCooldownMinutes;
                    if(atrCurrent < atrAverage * 0.8) // Low volatility = longer cooldown
                    {
                        cooldownMinutes = MaxCooldownMinutes;
                    }
                    else if(atrCurrent > atrAverage * 1.2) // High volatility = shorter cooldown
                    {
                        cooldownMinutes = MinCooldownMinutes;
                    }
                    else // Normal volatility
                    {
                        cooldownMinutes = (MinCooldownMinutes + MaxCooldownMinutes) / 2;
                    }
                    
                    cooldownEndTime = TimeCurrent() + cooldownMinutes * 60;
                    
                    Print("üìâ Loss: -$", DoubleToStr(MathAbs(profit), 2), 
                          " | Cooldown: ", cooldownMinutes, " min",
                          " | Consecutive losses: ", consecutiveLosses);
                }
            }
        }
    }
    
    lastHistoryTotal = totalHistoryNow;
}

//+------------------------------------------------------------------+
//| Expert deinitialization - Final Report                           |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    Print("üèÅ EA XAUUSD Smart v4.0 - Session Summary:");
    Print("üìä Total Trades: ", totalTrades);
    if(totalTrades > 0)
    {
        Print("üéØ Win Rate: ", DoubleToStr((double)winningTrades/totalTrades*100, 1), "%");
    }
    Print("üí∞ Final Equity: $", DoubleToStr(AccountEquity(), 2));
    Print("üöÄ Performance Multiplier: ", DoubleToStr(performanceMultiplier, 2));
    Print("Thanks for using EA XAUUSD Smart v4.0 - Tesla Autopilot Trading!");
}

//+------------------------------------------------------------------+
